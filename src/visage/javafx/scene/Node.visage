/*
 * Copyright (c) 2010-2011, Visage Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name Visage nor the names of its contributors may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package visage.javafx.scene;

/**
 * @author Stephen Chin <steveonjava@gmail.com>
 */
public class Node {
    public-read protected var wrappedNode:javafx.scene.Node;
    public var layoutX:Double on replace {
        if (isInitialized(this) or layoutX != 0) {
            wrappedNode.setLayoutX(layoutX);
        }
    }
    public var layoutY:Double on replace {
        if (isInitialized(this) or layoutY != 0) {
            wrappedNode.setLayoutY(layoutY);
        }
    }
    /**
     * <p>Defines the angle of rotation about the Node's center, measured in degrees. This is used to rotate the Node.</p>
     * <p>This rotation factor is not included in layoutBounds by default, which makes it ideal for rotating the entire node after all effects and transforms have been taken into account.</p>
     * <p>The pivot point about which the rotation occurs is the center of the untransformed layoutBounds.</p>
     * <p>Note that because the pivot point is computed as the center of this Node's layout bounds, any change to the layout bounds will cause the pivot point to change, which can move the object. For a leaf node, any change to the geometry will cause the layout bounds to change. For a group node, any change to any of its children, including a change in a child's geometry, clip, effect, position, orientation, or scale, will cause the group's layout bounds to change. If this movement of the pivot point is not desired, applications should instead use the Node's #transforms[] observableArrayList, and add a Rotate transform, which has a user-specifiable pivot point.</p>
     */
    public var rotate :Double on replace oldValue {
        if ((isInitialized(this) and (oldValue != rotate)) or (0 != rotate)) {
            wrappedNode.setRotate(rotate)
        }
    }
    /**
     * Indicates whether this node has a flexible range of acceptable sizes and allows its parent to resize it during layout. Nodes that should be treated as rigid will return false, in which case they may be moved but not resized during layout. Returns false by default.
     * @return whether or not this node can be resized by its parent during layout.
     */
    public function isResizable() :Boolean {
        wrappedNode.isResizable()
    }
    /**
     * If the node is resizable, will set its layout bounds to the specified width and height. If the node is not resizable, this method is a no-op. Resizable nodes are designed to be resized by their parent during layout and thus applications should not invoke this method directly.
     * @param width the target layout bounds width.
     * @param height the target layout bounds height.
     */
    public function resize(width :Double, height :Double) :Void {
        wrappedNode.resize(width, height)
    }
}
